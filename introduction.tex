\section{Introduction}

% Context
Domain-Specific Languages (DSLs) are software languages specifically tailored (e.g., syntax, semantics and tools) for a given problem space. While attractive in many application domains, the success of DSLs relies on the ability of language workbenches to support their specifications and automate the development of advanced and customized tools. In the last decade, various language workbenches have been proposed, with different facilities, formalisms and underlying implementation frameworks \cite{DBLP:journals/cl/ErdwegSVTBCGH0L15}.	

% Problem
While covering together a broad range of programming and modeling facilities, language workbenches face interoperability issues \cite{coulon:hal-01889155}. In particular language workbenches are usually well equipped in terms of formalisms, implementation frameworks and generative approaches to eventually obtain a fine-tuned specific set of tools, initially chosen for targeting the main scenarios. But then, it often fails to encompass other forms of implementation that would fit alternative scenarios. DSL specifications are hardly reusable for driving the development of various forms of DSL environments \cite{acher:hal-01061576}.

For example, while nowadays comprehensive BNF-based interpreted language specifications would drive the development of comprehensive DSL environments, it is hard to drive the development of alternate environments such as interactive computer programming environments. They are interactive environments that help to document (\emph{e.g.,}Â Jupyter\footnote{cf. \url{https://jupyter.org/}} \cite{Shen14}), to evaluate APIs (\cite{DBLP:conf/models/TombelleV06,sarid2016api}), to teach \cite{Allen:2002:DLP:563340.563395,Gray:2003:PGI:949344.949394,10.1007/BFb0033856}, to share knowledge (\emph{e.g.,} in science \cite{4160251,Perkel19}), or for arts \cite{quteprints31056}. In practice, most of today's DSL specifications have a single execution entry-point responsible for executing the whole program. Interactive environments support multiple entry points, with different strategies for managing the execution context and flow. Beyond the parser itself, the execution engine must turn into a \textit{Read-Eval-Print Loop} (REPL), that repeatedly reads an input from the user, evaluates it and prints a result. One of the main advantages of using a development environment that includes a REPL is to be able to write and execute a program piece by piece.

% Appraoch
In this paper, we propose an approach to automatically generate interactive computer programming environments from existing specifications of textual interpreted DSLs. More specifically, the approach reifies the relevant abstractions to use when specifying the DSL, and use a combination of static analysis and language transformations to automate the translation of both the language syntax and semantics. The syntax is converted such as it is possible to load partial program limited to single statements, and the semantics in the form of a language interpreter is turned into a REPL. Hence, we provide the required generative approach to automate the integration into a ready-to-use interactive computer programming environments in the form of both a language shell into Eclipse, and a specific Notebook (\emph{a la} Jupyter). 

We provide an implementation of the approach as a prototype on top of the Eclipse Modeling Framework \cite{steinberg2008emf}, which includes Ecore\footnote{cf. \url{https://www.eclipse.org/modeling/emf/}} for the syntax definition, Xtext\footnote{cf. \url{https://www.eclipse.org/Xtext}} for the textual syntax definition, and ALE\footnote{cf. \url{http://gemoc.org/ale-lang}} for the operational semantics definition. The approach would be similarly applied to other alternatives within EMF (\emph{e.g.,} Java or ATL interpreters, or using the native EMF Switch), or other implementation frameworks (\emph{e.g.}, Truffle-based interpreter). The approach applies to any DSL specification with a BNF definition of the syntax which includes an explicit definition of the execution flow, and an operational semantics specification in the form of a well-defined (top-down) interpreter or visitor.  

% Evaluation
We apply our approach on several DSLs, namely \emph{Logo}, \emph{MiniJava} and \emph{ThingML}~\cite{Harrand:2016:TLC:2976767.2976812}%, and demonstrate its applicability on a broad range of languages
. According to the different paradigms (\emph{e.g.}, control-flow vs. data-flow), we discuss the different ways to operate our approach and provide relevant interactive computer programming environments. 

% Conclusion
Hence, we provide a well-defined and automatic approach for complementing a modeling environment with an interactive computer programming environment. The resulting environment also provides several extension points to possibly customize the execution flow. Finally, we discuss several perspectives, including the deployment on web technologies.	


% Sectionning

The remainder of this paper is structured as follows. We motivate our contribution in Section \ref{motiv}, and introduce an illustrative example used throughout the paper. Section \ref{approach} presents an overview of our approach, while Section \ref{transformation} gives the details of the transformation of the syntax and the semantics. We present an evaluation of our approach in Section \ref{sec:evaluation}, and discuss related works in Section \ref{sec:rw}. Finally, a conclusion and future research directions are presented in Section \ref{sec:conclusion}.
